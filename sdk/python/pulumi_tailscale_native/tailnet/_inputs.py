# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AclRuleArgs',
    'AclRuleArgsDict',
    'CreateKeyArgs',
    'CreateKeyArgsDict',
    'DeviceKeyCapabilitiesArgs',
    'DeviceKeyCapabilitiesArgsDict',
    'KeyCapabilitiesArgs',
    'KeyCapabilitiesArgsDict',
    'NodeAttrsArgs',
    'NodeAttrsArgsDict',
    'SshRuleArgs',
    'SshRuleArgsDict',
]

MYPY = False

if not MYPY:
    class AclRuleArgsDict(TypedDict):
        action: pulumi.Input['AclRuleAction']
        """
        Tailscale ACL rules are "default deny".
        So the only possible value for an ACL
        rule is `accept`.
        """
        ports: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        users: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    AclRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AclRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['AclRuleAction'],
                 ports: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 users: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input['AclRuleAction'] action: Tailscale ACL rules are "default deny".
               So the only possible value for an ACL
               rule is `accept`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['AclRuleAction']:
        """
        Tailscale ACL rules are "default deny".
        So the only possible value for an ACL
        rule is `accept`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['AclRuleAction']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def ports(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter
    def users(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "users", value)


if not MYPY:
    class CreateKeyArgsDict(TypedDict):
        ephemeral: pulumi.Input[builtins.bool]
        preauthorized: pulumi.Input[builtins.bool]
        reusable: pulumi.Input[builtins.bool]
        tags: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    CreateKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CreateKeyArgs:
    def __init__(__self__, *,
                 ephemeral: pulumi.Input[builtins.bool],
                 preauthorized: pulumi.Input[builtins.bool],
                 reusable: pulumi.Input[builtins.bool],
                 tags: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(__self__, "ephemeral", ephemeral)
        pulumi.set(__self__, "preauthorized", preauthorized)
        pulumi.set(__self__, "reusable", reusable)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ephemeral(self) -> pulumi.Input[builtins.bool]:
        return pulumi.get(self, "ephemeral")

    @ephemeral.setter
    def ephemeral(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "ephemeral", value)

    @property
    @pulumi.getter
    def preauthorized(self) -> pulumi.Input[builtins.bool]:
        return pulumi.get(self, "preauthorized")

    @preauthorized.setter
    def preauthorized(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "preauthorized", value)

    @property
    @pulumi.getter
    def reusable(self) -> pulumi.Input[builtins.bool]:
        return pulumi.get(self, "reusable")

    @reusable.setter
    def reusable(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "reusable", value)

    @property
    @pulumi.getter
    def tags(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class DeviceKeyCapabilitiesArgsDict(TypedDict):
        create: pulumi.Input['CreateKeyArgsDict']
elif False:
    DeviceKeyCapabilitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceKeyCapabilitiesArgs:
    def __init__(__self__, *,
                 create: pulumi.Input['CreateKeyArgs']):
        pulumi.set(__self__, "create", create)

    @property
    @pulumi.getter
    def create(self) -> pulumi.Input['CreateKeyArgs']:
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: pulumi.Input['CreateKeyArgs']):
        pulumi.set(self, "create", value)


if not MYPY:
    class KeyCapabilitiesArgsDict(TypedDict):
        devices: pulumi.Input['DeviceKeyCapabilitiesArgsDict']
elif False:
    KeyCapabilitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeyCapabilitiesArgs:
    def __init__(__self__, *,
                 devices: pulumi.Input['DeviceKeyCapabilitiesArgs']):
        pulumi.set(__self__, "devices", devices)

    @property
    @pulumi.getter
    def devices(self) -> pulumi.Input['DeviceKeyCapabilitiesArgs']:
        return pulumi.get(self, "devices")

    @devices.setter
    def devices(self, value: pulumi.Input['DeviceKeyCapabilitiesArgs']):
        pulumi.set(self, "devices", value)


if not MYPY:
    class NodeAttrsArgsDict(TypedDict):
        attr: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        target: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    NodeAttrsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeAttrsArgs:
    def __init__(__self__, *,
                 attr: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 target: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(__self__, "attr", attr)
        pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def attr(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "attr")

    @attr.setter
    def attr(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "attr", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class SshRuleArgsDict(TypedDict):
        action: pulumi.Input['SshRuleAction']
        check_period: pulumi.Input[builtins.str]
        dst: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        src: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        users: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    SshRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SshRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['SshRuleAction'],
                 check_period: pulumi.Input[builtins.str],
                 dst: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 src: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 users: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "check_period", check_period)
        pulumi.set(__self__, "dst", dst)
        pulumi.set(__self__, "src", src)
        pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['SshRuleAction']:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['SshRuleAction']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="checkPeriod")
    def check_period(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "check_period")

    @check_period.setter
    def check_period(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "check_period", value)

    @property
    @pulumi.getter
    def dst(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "dst")

    @dst.setter
    def dst(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "dst", value)

    @property
    @pulumi.getter
    def src(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "src")

    @src.setter
    def src(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "src", value)

    @property
    @pulumi.getter
    def users(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "users", value)


